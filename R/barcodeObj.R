
check_sample_name <- function(barcodeObj) {
    metaname <- rownames(barcodeObj$metadata)

    # metadata v.s. messyBc
    if (all(metaname != names(barcodeObj$messyBc)))
        stop("The messyBc sample names are not consistent with metadata")

    # metadata v.s. cleanBc
    if (!is.null(barcodeObj$cleanBc)) {
        if (all(metaname != names(barcodeObj$cleanBc)))
            stop("The cleanBc sample names are not consistent with metadata")
    }
}

#' BarcodeObj object
#'
#' A S3 object holds the barcode data and sample metadata. A set of operations
#' can be applied to the BarcodeObj object for quality control and selecting
#' barcodes/samples. subset.
#'
#' @name BarcodeObj
#' @docType class
#' @details
#' The BarcodeObj object is a S3 object, which is a list under hood with class
#' name "BarcodeObj". There can be three elements in the BarcodeObj object,
#' which can be access by "$" operator, they are "messyBc", "cleanBc" and
#' "metadata". A BarcodeObj object can be generated by \code{bc_extract}
#' function. The \code{bc_extract} function can use various data types as input,
#' such as data.frame, fastq files and ShortReadQ.
#'
#' "messyBc" is a list holds the barcodes sequence before applying filtering,
#' where each element is a `data.table` corresponding to the successive samples.
#' Each table has 5 columns: 1. "reads_seq": full read sequence before
#' parsing. 2. "match_seq": the sequence matched by pattern. 3. "umi_seq"
#' (optional): UMI sequence, applicable when there is a UMI in `pattern` and
#' `pattern_type` argument. 4. "barcode_seq": barcode sequence. 5. "count": how
#' many reads a full sequence has. In this table, `barcode_seq` value may
#' be not unique, as two different full read sequences can contain the same
#' barcode sequence, due to the UMI or mutations in the constant region.
#'
#' "cleanBc" is a list holds the barcodes sequence after applying filtering,
#' where each element is a `data.table` corresponding to the successive samples.
#' The "cleanBc" element contains 2 columns 1. "barcode_seq": barcode sequence
#' 2. "counts": reads count, or UMI count if the cleanBc was created by
#' bc_cure_umi.
#'
#' @examples
#'
#' #######
#' # Get BarcodeObj using fastq file
#' fq_file <- system.file("extdata", "simple.fq", package="CellBarcode")
#' library(ShortRead)
#' bc_extract(fq_file, pattern = "AAAAA(.*)CCCCC")
#'
#' #######
#' # data manipulation on BarcodeObj object
#' data(bc_obj)
#'
#' bc_obj
#'
#' # Select barcodes
#' bc_subset(bc_obj, barcode = c("AACCTT", "AACCTT"))
#' bc_obj[c("AGAG", "AAAG"), ]
#'
#' # Select samples by meta data
#' bc_meta(bc_obj)$phenotype <- c("l", "b")
#' bc_meta(bc_obj)
#' bc_subset(bc_obj, sample = phenotype == "l")
#'
#' # Select samples by sample name
#' bc_obj[, "test1"]
#' bc_obj[, c("test1", "test2")]
#' bc_subset(bc_obj, sample = "test1", barcode = c("AACCTT", "AACCTT"))
#'
#' # Apply barcodes black list
#' bc_subset(
#' bc_obj,
#'     sample = c("test1", "test2"),
#'     barcode = c("AACCTT"))
#'
#' # Join two samples with different barcode sets
#' bc_obj["AGAG", "test1"] + bc_obj["AAAG", "test2"]
#'
#' # Join two samples with overlap barcodes
#' bc_obj_join <- bc_obj["AGAG", "test1"] + bc_obj["AGAG", "test2"]
#' bc_obj_join
#' # The same barcode will merged after applying bc_cure_depth()
#' bc_cure_depth(bc_obj_join)
#'
#' # Remove barcodes
#' bc_obj
#' bc_obj - "AAAG"
#'
#' # Select barcodes in white list
#' bc_obj
#' bc_obj * "AAAG"
#' ###
NULL

#' Manages barcodes and samples in the BarcodeObj object
#'
#' A set of functions and operators for subset and join of
#' BarcodeObj object(s). 
#' The bc_subset is used to select barcodes or samples in a BarcodeObj object.
#' \code{*} and \code{-} are for a subset of barcodes using white list and black list
#' respecrespectively.
#' Two BarcodeObj objects can be joined by \code{+}.
#'
#' @param barcodeObj A BarcodeObj.
#' @param barcode A vector of integer or string, indicating the selected
#' barcode.
#' @param sample A vector or an expression (not applicable for `[]` operator),
#' specifying the samples in the subsets. When the value is an expression, the
#' metadata can be used as variable.
#' @param black_list A character vector, specifying the black list with excluded barcodes.
#' @param white_list A character vector, giving the barcode white list. 
#' @param barcodeObj_x A BarcodeObj object.
#' @param barcodeObj_y A BarcodeObj object.
#' @param is_sample_quoted_exp A logical value. If TRUE, the
#' expression in \code{sample} argument will not be evaluated before executing
#' the function. 
#' @param ... Additional arguments.
#' @return A BarcodeObj object.
#'
#' @details
#' \code{bc_subset} and \code{[]}: Gets samples and barcodes subset.
#'
#' \code{+}: Combines two BarcodeObj objects. The \code{metadata}, \code{cleanBc} and
#' \code{messyBc} in BarcodeObj elements in BarcodeObj object will be joined. 
#' For the \code{metadata} element, the \code{sample_name} column will be used as the key for the
#' join, and the \emph{Full outer join} (the record in either BarcodeObj object) will
#' be returned. 
#' The \code{messyBc} and \code{cleanBc} from two objects are combined by rows.
#' 
#' \code{-}: removing barcodes in the black_list.
#'
#' \code{*}: selecting barcodes in the white_list.
#'
#' @examples
#' data(bc_obj)
#'
#' bc_obj
#'
#' # Select barcodes
#' bc_subset(bc_obj, barcode = c("AACCTT", "AACCTT"))
#' bc_obj[c("AGAG", "AAAG"), ]
#'
#' # Select samples by meta data
#' bc_meta(bc_obj)$phenotype <- c("l", "b")
#' bc_meta(bc_obj)
#' bc_subset(bc_obj, phenotype == "l")
#'
#' # Select samples by sample name
#' bc_obj[, "test1"]
#' bc_obj[, c("test1", "test2")]
#' bc_subset(bc_obj, sample = "test1", barcode = c("AACCTT", "AACCTT"))
#'
#' # Apply barcodes black list
#' bc_subset(
#' bc_obj,
#'     sample = c("test1", "test2"),
#'     barcode = c("AACCTT"))
#'
#' # Join two samples with different barcode sets
#' bc_obj["AGAG", "test1"] + bc_obj["AAAG", "test2"]
#'
#' # Join two samples with overlap barcodes
#' bc_obj_join <- bc_obj["AGAG", "test1"] + bc_obj["AGAG", "test2"]
#' bc_obj_join
#' # The same barcode will merged after applying bc_cure_depth()
#' bc_cure_depth(bc_obj_join)
#'
#' # Remove barcodes
#' bc_obj
#' bc_obj - "AAAG"
#'
#' # Select barcodes in white list
#' bc_obj
#' bc_obj * "AAAG"
#' ###
#' @export bc_subset
#' @rdname bc_subset
bc_subset <- function(barcodeObj,
    sample = NULL,
    barcode = NULL,
    black_list = NULL,
    is_sample_quoted_exp = FALSE) {

    # check sample names consistency
    check_sample_name(barcodeObj)

    metadata <- barcodeObj$metadata

    # preprocess sample selecting expression
    if (is_sample_quoted_exp) {
        sample_call <- sample
    } else {
        sample_call <- substitute(sample)
    }

    # TODO: The function only can apply the operation to the `messyBc` `cleanBc`
    # and `metadata`. We need to make it capable to apply the selection to all
    # information in the object.

    ## TODO: How do handle messyBc

    # select barcodes
    if (!is.null(barcode)) {
        # select barcodes in messyBc
        if (!is.null(barcodeObj$messyBc)) {
            barcodeObj$messyBc <- lapply(barcodeObj$messyBc, function(d) {
                d[barcode_seq %in% barcode]
            })
        }
        # select barcodes in cleanBc
        if (!is.null(barcodeObj$cleanBc)) {
            barcodeObj$cleanBc <- lapply(barcodeObj$cleanBc, function(d) {
                d[barcode_seq %in% barcode]
            })
        }
    }

    # remove barcodes
    if (!is.null(black_list)) {
        # remove barcodes in messyBc
        if (!is.null(barcodeObj$messyBc)) {
            barcodeObj$messyBc <- lapply(barcodeObj$messyBc, function(d) {
                d[!(barcode_seq %in% black_list)]
            })
        }

        # remove barcodes in cleanBc
        if (!is.null(barcodeObj$cleanBc)) {
            barcodeObj$cleanBc <- lapply(barcodeObj$cleanBc, function(d) {
                d[!(barcode_seq %in% black_list)]
            })
        }
    }

    # select samples
    if (!is.null(sample_call)) {
        
        # evaluate the sample argument
        sample_i <- eval(sample_call, metadata, parent.frame())

        # subset metadata
        barcodeObj$metadata <- metadata[sample_i, , drop = FALSE]

        # subset messyBc
        if (!is.null(barcodeObj$messyBc)) {
            barcodeObj$messyBc <-
                barcodeObj$messyBc[rownames(barcodeObj$metadata)]
        }

        # subset cleanBc
        if (!is.null(barcodeObj$cleanBc)) {
            barcodeObj$cleanBc <-
                barcodeObj$cleanBc[rownames(barcodeObj$metadata)]
        }
    }

    check_sample_name(barcodeObj)
    return(barcodeObj)
}

#' @export
#' @rdname bc_subset
"[.BarcodeObj" <-
    function(barcodeObj, barcode = NULL, sample = NULL, isSampleExpression=FALSE, ...) {
        # do not evaluate the expression
        if (isSampleExpression) {
            y_call <- substitute(sample)
        } else {
            y_call <- sample
        }
        # invoke bc_subset to done the job
        return(
            bc_subset(
                barcodeObj,
                sample = y_call,
                barcode = barcode,
                is_sample_quoted_exp = TRUE
            )
        )
    }

#' @rdname bc_subset
#' @export
bc_merge <- function(barcodeObj_x, barcodeObj_y) {
    barcodeObj_x + barcodeObj_y
}

#' @rdname bc_subset
#' @export
"+.BarcodeObj" <- function(barcodeObj_x, barcodeObj_y) {
    # TODO: Apply the merge to all parts of the data
    #       How to deal when two BarcodeObj have the same samples, the same
    #       samples will merged

    # merge metadata
    suffixes <- paste0(".", 
        c(
        deparse(substitute(barcodeObj_x)), 
        deparse(substitute(barcodeObj_y))
        ))
    metadata_x <- barcodeObj_x$metadata
    metadata_y <- barcodeObj_y$metadata
    metadata_xy <-
        merge(metadata_x, metadata_y, by = 0, all = TRUE, suffixes=suffixes, no.dups = TRUE)
    rownames(metadata_xy) <- metadata_xy$Row.names
    metadata_xy$Row.names <- NULL

    # merge messyBc
    # if the messyBc do not have the same header, do not merge them
    flag_remove_umi <- FALSE
    if (!all(names(barcodeObj_x$messyBc) == names(barcodeObj_y$messyBc))) {
        message("-message----\n+.BarcodeObj: You are merge data with UMI to data without UMI. The UMI info are discarded.\n------------")
        flag_remove_umi <- TRUE
    }

    barcodeObj_x$messyBc <-
        lapply(rownames(metadata_xy), function(sample_name) {
            d_x <- barcodeObj_x$messyBc[[sample_name]]
            d_y <- barcodeObj_y$messyBc[[sample_name]]
            if (flag_remove_umi) {
                if (!is.null(d_x$umi_seq))
                    d_x$umi_seq <- NULL
                if (!is.null(d_y$umi_seq))
                    d_y$umi_seq <- NULL
            }

            d_merged <- rbind(d_x, d_y)
            var_by <- setdiff(names(d_merged), "count")
            d_merged[, .(count = sum(count)), by = var_by]
        })

    names(barcodeObj_x$messyBc) <- rownames(metadata_xy)

    # merge cleanBc
    if (!is.null(barcodeObj_x$cleanBc) & !is.null(barcodeObj_y$cleanBc)) {
        barcodeObj_x$cleanBc <-
            lapply(rownames(metadata_xy), function(sample_name) {
                d_x <- barcodeObj_x$cleanBc[[sample_name]]
                d_y <- barcodeObj_y$cleanBc[[sample_name]]

                d_merged <- rbind(d_x, d_y)
                var_by <- setdiff(names(d_merged), "count")
                d_merged[, .(count = sum(count)), by = var_by]
            })

        names(barcodeObj_x$cleanBc) <- rownames(metadata_xy)
    } else if (is.null(barcodeObj_x$cleanBc) + is.null(barcodeObj_y$cleanBc) == 1) {
        message("-message----\n+.BarcodeObj: One of the BarcodesObj does not have cleanBc, discard the cleanBc while merging.\n------------")
        barcodeObj_x$cleanBc <- NULL
        bc_meta(barcodeObj_x, "depth_cutoff") <- NULL
    }

    barcodeObj_x$metadata <- metadata_xy
    barcodeObj_x
}

#' @rdname bc_subset
#' @export
"-.BarcodeObj" <- function(barcodeObj, black_list) {
    bc_subset(barcodeObj, black_list = black_list)
}

#' @rdname bc_subset
#' @export
"*.BarcodeObj" <- function(barcodeObj, white_list) {
    bc_subset(barcodeObj, barcode = white_list)
}

#' Gets barcode sequences
#'
#' \code{bc_barcodes} used to get the barcode sequences in BarcodeObj object. The input 
#' BarcodesObj object should be pre-processed by \code{bc_cure_*} functions.
#'
#' @param barcodeObj A BarcodeObj object.
#' @param unlist A logical value. If TRUE, the function returns a vector
#' of unique barcode list from all samples; otherwise a list will be
#' returned, with each element containing the barcodes of a sample.
#' @return A character vector or a list.
#' @examples
#' data(bc_obj)
#'
#' # get unique barcode vector of all samples
#' bc_barcodes(bc_obj)
#'
#' # get a list with each element containing barcodes from one sample
#' bc_barcodes(bc_obj, unlist = FALSE)
#'
#' ###
#' @export
bc_barcodes <- function(barcodeObj, unlist = TRUE) {
    if (is.null(barcodeObj$cleanBc)) {
        stop("No cleanBc found, please run bc_cure_* first.")
    }

    d <- lapply(barcodeObj$cleanBc, function(x) {
        x$barcode_seq
        })
    if (unlist) {
        unlist(d) %>% as.character %>% unique
    } else {
        names(d) = names(barcodeObj$cleanBc)
        d
    }
}

#' Gets sample names in BarcodeObj
#'
#' Get or set sample names in BarcodeObj object.
#'
#' @param barcodeObj A BarcodeObj object.
#' @param value A string vector setting the new sample names, with the length of the samples number in
#' BarcodeObj object.
#' @return A character vector
#' @examples
#' data(bc_obj)
#'
#' bc_names(bc_obj)
#' bc_names(bc_obj) <- c("new1", "new2")
#' @export
bc_names <- function(barcodeObj) {
    check_sample_name(barcodeObj)
    rownames(barcodeObj$metadata)
}

#' @rdname bc_names
#' @export
"bc_names<-" <- function(barcodeObj, value) {
    # if the sample names are not consistent stop
    check_sample_name(barcodeObj)

    # check if the new names fit the sample number
    if (length(unique(value)) != nrow(barcodeObj$metadata))
        stop("The given sample names do not have the same length with sample number. Or the sample names are not unique.")

    # If exists messyBc renew the name
    if (!is.null(barcodeObj$messyBc)) 
        names(barcodeObj$messyBc) <- value
    
    # If exists cleanBc renew the name
    if (!is.null(barcodeObj$cleanBc)) 
        names(barcodeObj$cleanBc) <- value

    # renew sample name in metadata
    rownames(barcodeObj$metadata) <- value
    # barcodeObj$metadata <- value
    #
    check_sample_name(barcodeObj)
    barcodeObj
}

#' Accesses and sets metadata in BarcodeObj object
#'
#' Accesses and sets metadata in BarcodeObj object
#'
#' @param barcodeObj A BarcodeObj object.
#' @param key A string, identifying the metadata record name to be modified.
#' @param value A string vector or a data.frame. When the "value" is a vector, it
#' should have the length of sample number in the BarcodeObj object and the
#' "key" variable is necessary. Otherwise, when the "value" is data.frame, the
#' row name of the data.frame should be the sample name, and each column as a
#' metadata record. 
#' @return A data.frame
#' @examples
#' data(bc_obj)
#'
#' # get the metadata data.frame
#' bc_meta(bc_obj)
#'
#' # assign value to a metadata by $ operation
#' bc_meta(bc_obj)$phenotype <- c("l", "b")
#'
#' # assign value to a metasta by "key" argument
#' bc_meta(bc_obj, key = "sample_type") <- c("l", "b")
#'
#' # show the updated the metadata
#' bc_meta(bc_obj)
#'
#' # assign a new data.frame as metadata
#' metadata <- data.frame(
#'     sample_name <- c("test1", "test2"),
#'     phenotype <- c("l", "b")
#'     )
#' rownames(metadata) = bc_names(bc_obj)
#' bc_meta(bc_obj) <- metadata
#' ###
#' @export
bc_meta <- function(barcodeObj) {
    check_sample_name(barcodeObj)
    barcodeObj$metadata
}

#' @rdname bc_meta
#' @export
"bc_meta<-" <- function(barcodeObj, key = NULL, value) {
    # check sample names consistency
    check_sample_name(barcodeObj)

    # if no key is given, update the metadata
    if (is.null(key)) {
        if (!is(value, "data.frame"))
            stop("The input data is not data.frame")

        # if new value matches the sample number
        if (length(value) != 1 & nrow(value) != nrow(barcodeObj$metadata))
            stop("The given meta data does not have correct length.")

        barcodeObj$metadata <- value
    } else {
        # if new value matches the sample number
        if (length(value) != 1 & length(value) != nrow(barcodeObj$metadata))
            stop("The given meta data does not have correct length.")

        barcodeObj$metadata[[key]] <- value
    }

    # check sample names consistency
    check_sample_name(barcodeObj)

    barcodeObj
}


#' Transforms BarcodeObj object into other data type
#'
#' Transforms BarcodeObj object into data.frame, data.table or matrix.
#'
#' @param barcodeObj A BarcodeObj.
#' @return A data.frame, with two columns named `barcode_seq` and `count`.
#' @examples
#' data(bc_obj)
#'
#' bc_obj <- bc_cure_depth(bc_obj)
#'
#' # get data.frame
#' bc_2df(bc_obj)
#'
#' # get data.table
#' bc_2dt(bc_obj)
#'
#' # get matrix
#' bc_2matrix(bc_obj)
#'
#' ###
#' @export
bc_2df <- function(barcodeObj) {
    bc_2dt(barcodeObj) %>% as.data.frame
}

#' @rdname bc_2df
#' @return A data.table, with two columns named `barcode_seq` and `count`.
#' @export
bc_2dt <- function(barcodeObj) {
    # TODO: enable messyBc?

    if (is.null(barcodeObj$cleanBc)) {
        stop("No cleanBc found, please run bc_cure_* first.")
    }

    d <- barcodeObj$cleanBc %>% rbindlist(idcol = TRUE)
    names(d)[1] <- "sample_name"
    return(d)
}


#' @rdname bc_2df
#' @return A data matrix with sample by columns and barcode by rows.
#' @export
bc_2matrix <- function(barcodeObj) {
    # TODO: enable messyBc?

    if (is.null(barcodeObj$cleanBc)) {
        stop("No cleanBc found, please run bc_cure_* first.")
    }

    # TODO: use sparse matrix?
    # long shape data to wide shape data
    # with barcode_seq by row and sample by column
    d <- bc_2dt(barcodeObj) %>% data.table::dcast(barcode_seq ~ sample_name,
        value.var = "count",
        fill = 0)
    m <- data.frame(d[,-1]) %>% data.matrix
    rownames(m) = d[, barcode_seq]
    m
}

count_BarcodeObj <- function(barcodeObj) {
    summary_res <- list()

    # number of barcodes for each samples in messyBc
    summary_res$messyBc_barcode_n <- lapply(barcodeObj$messyBc, nrow)
    names(summary_res$messyBc_barcode_n) <- rownames(barcodeObj$metadata)

    # number of barcodes for each samples in cleanBc
    if (!is.null(barcodeObj$cleanBc)) {
        summary_res$cleanBc_barcode_n <- lapply(barcodeObj$cleanBc, nrow)
        names(summary_res$cleanBc_barcode_n) <- rownames(barcodeObj$metadata)
    }

    summary_res
}

#' Formats BarcodeObj object
#'
#' Formats the summary of BarcodeObj object for pretty print.
#'
#' @param x A BarcodeObj
#' @param ... Additional arguments
#' @return Formated BarcodeObj summary.
#'
#' @examples
#' data(bc_obj)
#'
#' # format BarcodeObj for pretty print
#' format(bc_obj)
#'
#' ###
#' @seealso \code{\link[CellBarcode]{print.BarcodeObj}}
#' @export
format.BarcodeObj <- function(x, ...) {
    summary_res <- count_BarcodeObj(x)

    # elements list in BarcodeObj
    subjects <- paste(names(x), collapse = "  ")

    # number of samples
    messyBc_n <- length(summary_res$messyBc_barcode_n)

    messyBc_info <-
        lapply(seq_along(summary_res$messyBc_barcode_n), function(i) {
            # sample name
            sample_name <- names(summary_res$messyBc_barcode_n)[i]
            # barcode number
            n <- summary_res$messyBc_barcode_n[i]
            stringr::str_glue("    In sample ${sample_name} there are: {n} Tags")
            }) %>% unlist %>% paste(collapse = "\n")

    # elements in metadata
    metadata_info <- paste(names(x$metadata), collapse = "  ")
    metadata_n <- length(names(x$metadata))


    res <- stringr::str_glue(
"Bonjour le monde, This is a BarcodeObj.
----------
It contains: 
{subjects}
----------
$metadata: {metadata_n} meta data field(s) available
{metadata_info}
----------
$messyBc: {messyBc_n} Samples for raw barcodes
{messyBc_info}"
    )


    # cleanBc
    if (!is.null(summary_res$cleanBc_barcode_n)) {
        # sample number
        cleanBc_n <- length(summary_res$cleanBc_barcode_n)
        cleanBc_info <-
            lapply(seq_along(summary_res$cleanBc_barcode_n),
                function(i) {
                    # sample name
                    sample_name <-
                        names(summary_res$cleanBc_barcode_n)[i]
                    # sample number
                    n <- summary_res$cleanBc_barcode_n[i]
                    stringr::str_glue("    In sample ${sample_name} there are: {n} barcodes")
                }) %>% unlist %>% paste(collapse = "\n")
        res_cleanBc <- stringr::str_glue(
"----------
$cleanBc: {cleanBc_n} Samples for cleaned barcodes
{cleanBc_info}"
        )
        res <- stringr::str_c(res, "\n", res_cleanBc)
    }
    res
}

#' Print the summary of BarcodeObj
#'
#' @param x A BarcodeObj
#' @param ... Additional arguments
#' @return Print formated BarcodeObj summary.
#'
#' @examples
#' data(bc_obj)
#'
#' # print BarcodeObj
#' print(bc_obj)
#' ###
#' @seealso \code{\link[CellBarcode]{format.BarcodeObj}}
#' @export
print.BarcodeObj <- function(x, ...) {
    cat(format(x), "\n")
}
