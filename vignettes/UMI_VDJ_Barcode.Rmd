---
title: "Analyzing UMI Barcode with Bc"
author: "Wenjie Sun"
package: Bc
output: 
  BiocStyle::pdf_document
vignette: >
  %\VignetteIndexEntry{UMI_Barcode}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  error = FALSE,
  warn = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(data.table)
library(ggplot2)
library(Bc)
```

# Introduction

## About the package

**What's this package used for?**

  DNA barcode (synonyms?) is powerful tool for clonal tracing study. This
  package provides a toolbox for DNA barcode analysis. 

**What types of barcode can this package handle?**

  The package can handle all kinds of barcodes, as long as the barcode have a
  pattern can be matched by regular expression, and the barcode is withine a
  single reads. And it can handle barcode with flexible length, and barcode
  with UMI (unique molecular identifier).

  Actually, this tool also can be used for preprocssing of amplicon data
  analysis such as CRISPR gRNA screening, immue repotoire sequencing and meta
  genome data.

**What the package can do?**

  The package provides functions for 1). Sequence quality control and
  filtering, 2). Extract barcodes (and UMI) from seqeunce, 3). sample and
  barcode management with metadata, 4). Barcode filtering.

## About function naming

Most of the functions in this packages have names with `bc_` as initiation. We
hope it can facilitate the syntax auto-complement function of IDE (integrated
development toolkit) or IDE like tools such as RStudio, R-NVIM (in VIM), and
ESS (in Emacs). By typing `bc_` you can have a list of suggested functions,
then you can pick the function you needed from the list.

## About test data set

The test data set in this package can be accessed by

```{r}
system.file("extdata", "mef_test_data", package="Bc")
```

The data are from Jos et. al (TODO: citation). There are 7 MEF (mouse embryo
fiboblast) lines with different DNA barcodes. Those barcodes are in vivo
inducible VDJ barcodes. These MEF lines were mixed in a ratio of
1:2:4:8:16:32:64.

| sequence                          | clone size 2^x |
| ---                               | ---            |
| AAGTCCAGTTCTACTATCGTAGCTACTA      | 1              |
| AAGTCCAGTATCGTTACGCTACTA          | 2              |
| AAGTCCAGTCTACTATCGTTACGACAGCTACTA | 3              |
| AAGTCCAGTTCTACTATCGTTACGAGCTACTA  | 4              |
| AAGTCCATCGTAGCTACTA               | 5              |
| AAGTCCAGTACTGTAGCTACTA            | 6              |
| AAGTCCAGTACTATCGTACTA             | 7              |

Then, 5 pools of 196 to 50000 cells are prepared from the MEF lines mixture.
For each pool 2 technical replicates (NGS libraries) are prepared and
sequenced, finally result in 10 samples. 

| sample name | cell number | replication |
| ---         | ---         | ---         |
| 195_mixa    | 195         | mixa        |
| 195_mixb    | 195         | mixb        |
| 781_mixa    | 781         | mixa        |
| 781_mixb    | 781         | mixb        |
| 3125_mixa   | 3125        | mixa        |
| 3125_mixb   | 3125        | mixb        |
| 12500_mixa  | 12500       | mixa        |
| 12500_mixb  | 12500       | mixb        |
| 50000_mixa  | 50000       | mixa        |
| 50000_mixb  | 50000       | mixb        |

The original FASTQ files are relatively huge, only 2000 reads for each sample
have been randomly sampled as test set here.

```{r smaples}
example_data <- system.file("extdata", "mef_test_data", package = "Bc")
fq_files <- dir(example_data, "fastq.gz", full=T)
```

# Installation

Install from Bioconducotr.

```{r installation Bioconducotr, eval=F}
if(!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("Bc")
```

Install the devel version from github.

```{r installation devel}
# TODO:
```

# A basic workflow

```{r basic_workflow}
library(Bc)
library(magrittr)

# The example data is the mix of MEF lines with known barcodes
# 2000 reads for each file have been sampled for this test dataset
# TODO: Citation of the paper:
example_data <- system.file("extdata", "mef_test_data", package = "Bc")
fq_files <- dir(example_data, "gz", full=T)

# prepare metadata
metadata <- stringr::str_split_fixed(basename(fq_files), "_", 10)[, c(4, 6)]
metadata <- data.frame(metadata)
sample_name <- apply(metadata, 1, paste, collapse = "_")
colnames(metadata) = c("cell_number", "replication")
rownames(metadata) = sample_name
metadata

# extract UMI barcode with regular expression
bc_obj <- bc_extract(
  fq_files,
  pattern = "(.{12})CTCGAGGTCATCGAAGTATCAAG(.+)TAGCAAGCTCGAGAGTAGACCTACT", 
  pattern_type = c("UMI" = 1, "barcode" = 2),
  sample_name = sample_name,
  metadata = metadata
)
bc_obj

# sample subset operation, select technical repeats 'mixa'
bc_sub = bc_obj[, replication == "mixa"]
bc_sub 

# filter the barcode, UMI barcode amplicon > 1 & umi counts > 1
bc_sub <- bc_cure_umi(bc_sub, depth = 1) %>% bc_cure_depth(depth = 1)

# select barcodes with a white list
bc_sub[c("AAGTCCAGTACTATCGTACTA", "AAGTCCAGTACTGTAGCTACTA"), ]

# export the barcode counts to data.frame
bc_2df(bc_sub)

# export the barcode counts to matrix
bc_2matrix(bc_sub)
```


# Sequence quality control

## Evaluate sequence quality

`bc_seqQC` function is for checking the sequencing quality. The output is a
`BarcodeQcSet` object, when multiple samples as input; otherwise a `BarcodeQC`
object will be returned. In addition, `bc_seqQC` also can handle the
`ShortReadQ`, `DNAStringSet` and other data types.

```{r quality_control_1}
qc_noFilter <- bc_seqQC(fq_files)
names(qc_noFilter[[1]])
class(qc_noFilter)
```

`plot` function can be invoke with a `BarcodeQcSet` as argument, and the output
is QC summary. There are two fields: one shows the ratio of ATCG bases by each
sequencing cycle with each sample in row, and another one shows average
sequencing quality index of each cycle. 

For the test set, the first 12 bases are UMI, which are random. Followed by the
constant region of barocde, which have specific base pair for each sequencing
cycle.

```{r qc_figure_set1}
plot(qc_noFilter) 
```

We can choose one of the `BarcodeQc` in the `BarcodeQcSet` object. In the
output, there are three fields. The top left one shows the amplicons sequencing
depth distribution, the top right figure shows the "ATCG" bases ratio by each
sequencing cycle, and the last one shows the sequencing quality by sequencing
cycle.

```{r qc_figure_single1}
class(qc_noFilter[[1]])
plot(qc_noFilter[[1]]) 
```

## Filter low quality sequences

`bc_filterSeq` read in the sequence data and apply filter, then return a
`ShortReadQ` object which contains the filtered sequences. 

The `bc_filterSeq` function can read fastq files, and it can also handle
sequencing reads in `ShortReadQ`, `DNAStringSet` and `data.frame`.

The currently available filter parameters are: 
- min_average_quality: base average sequencing quality.
- min_read_length: read segment length.
- N_threshold: the limitation of "N" base in sequence.
 
```{r filter_low_quality_seq}
# TODO: output the filtering percentage
# TODO: Trimming
fq_filter <- bc_filterSeq(
  fq_files,
  min_average_quality = 30,
  min_read_length = 60,
  sample_name = sample_name)

fq_filter
plot(bc_seqQC(fq_filter))
```

# Parse reads to get barcode

One of the core applications of this package is parsing the sequences to get
the barcode (and UMI). Our package utilized the regular expression to identify
barcodes (and UMI) from sequence. It needs to tell `bc_extract` the structure
of your input sequences.

These 3 arguments are necessary, they are:
- x: the sequence data, it can be in fastq, `ShortReadQ`, `DNAStringSet` or
  `data.frame` format.
- pattern: the sequence pattern regular expression.
- pattern_type: pattern description.

The `pattern` argument is the regular expression, it tells the function where
is the barcode (or UMI). We capture the barcode (or UMI) by `()` in the
backbone. For the sequence captured by `()`, the `pattern_type` argument tells
which is the UMI or the barcode. In the example 

```{r}
pattern <- "([ACGT]{12})CTCGAGGTCATCGAAGTATCAAG([ACGT]+)TAGCAAGCTC"
pattern_type <- c("UMI" = 1, "barcode" = 2)
```

1. The sequence starts with 12 base pairs of random sequence, which is UMI. It
   is the firstly captured by `()` in `pattern` argument, and correspoing to
   `UMI = 1` in `pattern_type` argument.
2. Then, there is a constant sequence: `CCTCGAGGTCATCGAAGTATCAAG`.
3. Followed the constant region, there is flexible random sequence. It is the
   barcode which is trapped by second `()`, and it is defined by `barcode = 2`
   in `pattern_type` argument.
4. In the end of the sequence, it is a constant sequence `TAGCAAGCTC`.

In the UMI pattern `[ACGT]{12}`, the `[ACGT]` means it can be one of the "A",
"C", "G" and "T", and the `{12}` means there are 12 `[ACGT]`. In the barcode
pattern `[ACGT]+`, the `+` denotes that there is at least one of the `[ACGT]`.

The `bc_extract` function returns a `BarcodeObj` object if the input is a list
or a vector of Fastq files, and it returns a `data.frame` if input is one
sample. In the later case the `data.frame` has 5 columns:

1. reads_seq: sequence of the reads before parsing.
2. match_seq: the sequence among read matched by pattern.
3. umi_seq (optional): UMI sequence, applicable when there is UMI in `pattern`
   and `pattern_type` argument.
4. barcode_seq: barcode sequence.
5. count: reads number.

The `match_seq` is part of `reads_seq`. The `umi_seq` and `barcode_seq` are
part of `match_seq`. Be attention that, the `reads_seq` is the unique id for
each row. The `match_seq`, `umi_seq` or `barcode_seq` can be duplicated, due to
the potential variation in the region outside of `match_seq`. Please keep this
in mind when you use data in `$messyBc`
to perform the analysis.

The `BarcodeObj` is a `List` under the hood. The `bc_extract` will create
`messyBc` and `metadata` in the list. And the `messyBc` is a list too, within
which each element is a `data.framee` corresponds to a sample. The `data.frame`
has 5 columns 1). `reads_seq`, 2). `match_seq`, 3). `umi_seq`, 4).
`barcode_seq` and 5). `count`, which have been discribed above 

## Process sequencing without UMI 

In the following example, only barcode is extracted.

```{r extract_barcode_no_UMI}
pattern <- "CGAAGTATCAAG(.+)TAGCAAGCTCGAGAGTAGACCTACT"
bc_obj <- bc_extract(
  fq_filter,
  sample_name = sample_name,
  pattern = pattern,
  pattern_type = c(barcode = 1))

bc_obj
names(bc_obj$messyBc[[1]])
```

## Sequencing with UMI

In the following example, both UMI and barcode are extracted.

```{r extract_barcode_with_UMI}
pattern <- "([ACGT]{12})CTCGAGGTCATCGAAGTATCAAG([ACGT]+)TAGCAAGCTC"
bc_obj_umi <- bc_extract(
  fq_filter,
  sample_name = sample_name,
  pattern = pattern,
  maxLDist = 0,
  pattern_type = c(UMI = 1, barcode = 2))

class(bc_obj_umi)
bc_obj_umi
```

# Data managemeent of `BarcodeObj`

Besides, we provide a serials operator to handle the data for `BarcodeObj`
object. You could easily selected one or several samples by their names,
indexes or metadata.


Select sample by `$` operation

```{r}
names(bc_obj_umi$messyBc[["781_mixb"]])
```

Select sample by sample names

```{r}
bc_obj_umi = bc_obj_umi[, c("781_mixa", "781_mixb")]
bc_names(bc_obj_umi)
```

Set metadata

```{r}
bc_meta(bc_obj_umi)$rep <- c("a", "b")
bc_meta(bc_obj_umi)
```

Select sample by metadata

```{r}
bc_obj_umi[, rep == "a"]
bc_subset(bc_obj_umi, sample = rep == "a")
```

# Barcode filtering

The `bc_extract` will give you all the barcodes found in the sequences. Some of
the identified barcodes may come from PCR or sequencing errors. The `bc_cure_*`
functions perform the filtering for identifying true barcode. The `bc_cure_*`
functions create or update `cleanBc` element in `BarcodeObj`. The `cleanBc`
element contains 2 columns
  - barcode_seq: barcode sequence
  - counts: reads depth or UMI count

In the `bc_cure_*` function family, there are:

- `bc_cure_umi` it process `messyBc` element, do the filtering based on the
  UMI-barcode tag depth, the available arguments, 
  - depth: the threshold of UMI-barcode depth.
  - doFish: if true, "fish" the true UMI-barcode tags with depth lower than
    threshold. The consequence of "fish" will not increse the identified
    barcodes number, but the UMI counts will increased due to including the low
    depth UMI-barcode tags.
  - isUniqueUMI: a UMI can related to several barcodes, do you believe the UMI
    is absolute unique? If yes, then the most abundent UMI-barcode will be
    picked for a specific UMI, and sub-abundent barcodes with the same UMI are
    obsolete.
- `bc_cure_cluster` do the clustering to merge the barcode with sub-abundent
  depth (or UMI counts) to the most abundent ones, it needs the `cleanBc`
  element and will update it.
  - distance: the distance threshold to triger the merge.
  - barcode_n: max barcode number, when reach this number the clustering will
    stopped and the rest barcodes are obsolete.
  - dist_method: the distance algorithm, currently only "hamm" available.
  - merge_method: the distance algorithm, only "greedy" available currently.
- `bc_cure_depth` perform filtering by the sequence depth or UMI counts.
  - depth: the threshold of sequence depth or UMI counts
  - isUpdate: if true the bc_cure will perfom the filter on the `cleanBc`
    element and update it, otherwise the `messyBc` will be used and update the
    `cleanBc`.
 
```{r correct_barcodde_with_UMI}
# Filter the barcode with UMI-barcode tags > 1, and treat UMI as absolute
# unique and do "fish"
bc_obj_umi <- bc_cure_umi(bc_obj_umi, depth = 1, isUniqueUMI = T, doFish = T)
# Apply the UMI count filter, keep barcode > 3 UMI
bc_obj_umi <- bc_cure_depth(bc_obj_umi, depth = 3)
bc_meta(bc_obj_umi)
bc_obj_umi
bc_2matrix(bc_obj_umi)
```

# Miscellaneous

We provides functions to transform the barcode information in `BarcodeObj` to
more general R data types.

## Sample names

```{r}
bc_names(bc_obj_umi)
```

## `BarcodeObj` to `data.frame`

The `cleanBc` will be used, the columns in the output:
  - barcode_seq: barcode sequence
  - sample_name
  - count: reads or UMI count
 
```{r}
bc_2df(bc_obj_umi)
```

Or if you prefer `data.table`

```{r}
bc_2dt(bc_obj_umi)
```

## BarcodeObj to matrix

The `cleanBc` will be used, the output is reads count or UMI count matrix, with
barcode in row and sample in column.

```{r misc}
bc_2matrix(bc_obj_umi)
```

## Combination

You can combined several operation together to accomplish more complex
operation.

In the following examples, sample barcode is selected in one sample, then
get the result in `data.frame` format.

```{r}
bc_2df(bc_obj_umi[bc_barcodes(bc_obj_umi)[1], "781_mixa"])
```

# Session Info

```{r}
sessionInfo()
```
