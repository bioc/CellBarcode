---
title: "Analyzing UMI Barcode with Bc"
author: 
  - Wenjie Sun^[sunwjie@gmail.com]
  - Anne-Marie Lyne^[Anne-Marie.Lyne@curie.fr]
package: Bc
output: 
  BiocStyle::html
vignette: >
  %\VignetteIndexEntry{UMI_Barcode}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  error = FALSE,
  warn = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}

# install.packages("ShortRead")
# install.packages("egg")
# install.packages("BiocStyle")

library(data.table)
library(ggplot2)
library(Bc)
```

# Introduction

## About the package

**What's this package used for?**

  DNA barcoding (genetic lineage tracing) is a powerful tool for lineage tracing and clonal tracking studies. This
  package provides a toolbox for DNA barcode analysis, from extraction from fastq files to barcode error correction and quantification. 

**What types of barcode can this package handle?**

  The package can handle all kinds of barcodes, as long as the barcodes have a
  pattern which can be matched by a regular expression, and each barcode is within a
  single sequencing read. It can handle barcodes with flexible length, and barcodes
  with UMI (unique molecular identifier).

  This tool can also be used for the pre-processing part of amplicon data
  analysis such as CRISPR gRNA screening, immune repertoire sequencing and meta
  genome data.

**What the package can do?**

  The package provides functions for 1). Sequence quality control and
  filtering, 2). Barcode (and UMI) extraction from sequencing reads, 3). Sample and
  barcode management with metadata, 4). Barcode filtering.

## About function naming

Most of the functions in this packages have names with `bc_` as initiation. We
hope it can facilitate the syntax auto-complement function of IDE (integrated
development toolkit) or IDE-like tools such as RStudio, R-NVIM (in VIM), and
ESS (in Emacs). By typing `bc_` you can have a list of suggested functions,
then you can pick the function you need from the list.

## About test data set

The test data set in this package can be accessed by

```{r}
system.file("extdata", "mef_test_data", package="Bc")
```

The data are from Jos et. al (TODO: citation). There are 7 mouse embryo
fibroblast (MEF) lines with different DNA barcodes. The barcodes are in vivo
inducible VDJ barcodes (TODO: add citation when have). These MEF lines were mixed in a ratio of
1:2:4:8:16:32:64.

| sequence                          | clone size 2^x |
| ---                               | ---            |
| AAGTCCAGTTCTACTATCGTAGCTACTA      | 1              |
| AAGTCCAGTATCGTTACGCTACTA          | 2              |
| AAGTCCAGTCTACTATCGTTACGACAGCTACTA | 3              |
| AAGTCCAGTTCTACTATCGTTACGAGCTACTA  | 4              |
| AAGTCCATCGTAGCTACTA               | 5              |
| AAGTCCAGTACTGTAGCTACTA            | 6              |
| AAGTCCAGTACTATCGTACTA             | 7              |

Then 5 pools of 196 to 50000 cells were prepared from the MEF lines mixture.
For each pool 2 technical replicates (NGS libraries) were prepared and
sequenced, finally resulting in 10 samples. 

| sample name | cell number | replication |
| ---         | ---         | ---         |
| 195_mixa    | 195         | mixa        |
| 195_mixb    | 195         | mixb        |
| 781_mixa    | 781         | mixa        |
| 781_mixb    | 781         | mixb        |
| 3125_mixa   | 3125        | mixa        |
| 3125_mixb   | 3125        | mixb        |
| 12500_mixa  | 12500       | mixa        |
| 12500_mixb  | 12500       | mixb        |
| 50000_mixa  | 50000       | mixa        |
| 50000_mixb  | 50000       | mixb        |

The original FASTQ files are relatively large, so only 2000 reads for each sample
have been randomly sampled as a test set here.

```{r smaples}
example_data <- system.file("extdata", "mef_test_data", package = "Bc")
fq_files <- dir(example_data, "fastq.gz", full=TRUE)
```

# Installation

Install from Bioconductor.

```{r installation Bioconducotr, eval=FALSE}
if(!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("Bc")
```

Install the devel version from Github.

```{r installation devel}
# install.packages("remotes")
remotes::install_github("wenjie1991/Bc")
```

# A basic workflow

Here is an example of a basic workflow:

```{r basic_workflow}
library(Bc)
library(magrittr)

# The example data is the mix of MEF lines with known barcodes
# 2000 reads for each file have been sampled for this test dataset
# TODO: Citation of the paper:
example_data <- system.file("extdata", "mef_test_data", package = "Bc")
fq_files <- dir(example_data, "gz", full=TRUE)

# prepare metadata
metadata <- stringr::str_split_fixed(basename(fq_files), "_", 10)[, c(4, 6)]
metadata <- data.frame(metadata)
sample_name <- apply(metadata, 1, paste, collapse = "_")
colnames(metadata) = c("cell_number", "replication")
rownames(metadata) = sample_name
metadata

# extract UMI barcode with regular expression
bc_obj <- bc_extract(
  fq_files,
  pattern = "(.{12})CTCGAGGTCATCGAAGTATCAAG(.+)TAGCAAGCTCGAGAGTAGACCTACT", 
  pattern_type = c("UMI" = 1, "barcode" = 2),
  sample_name = sample_name,
  metadata = metadata
)
bc_obj

# sample subset operation, select technical repeats 'mixa'
bc_sub = bc_obj[, replication == "mixa"]
bc_sub 

# filter the barcode, UMI barcode amplicon > 1 & UMI counts > 1
bc_sub <- bc_cure_umi(bc_sub, depth = 1) %>% bc_cure_depth(depth = 1)

# select barcodes with a white list
bc_sub[c("AAGTCCAGTACTATCGTACTA", "AAGTCCAGTACTGTAGCTACTA"), ]

# export the barcode counts to data.frame
bc_2df(bc_sub)

# export the barcode counts to matrix
bc_2matrix(bc_sub)
```


# Sequence quality control

## Evaluate sequence quality

In a full analysis starting from fastq files, the first step is to check the seqencing quality and filter as required. The `bc_seqQC` function is for checking the sequencing quality. If multiple samples are input the output is a `BarcodeQcSet` object, otherwise a `BarcodeQC` object will be returned. In addition, `bc_seqQC` also can handle the
`ShortReadQ`, `DNAStringSet` and other data types.

```{r quality_control_1}
qc_noFilter <- bc_seqQC(fq_files)
names(qc_noFilter[[1]])
class(qc_noFilter)
```

The `plot` function can be invoked with a `BarcodeQcSet` as argument, and the output
is a QC summary with two panels. The first shows the ratio of ATCG bases for each
sequencing cycle with one sample per row; this allows the user to, for example, identify constant or random parts of the sequencing read. The second figure shows the average sequencing quality index of each cycle (base). 

For the test set, the first 12 bases are UMI, which are random. This is followed by the
constant region of the barcode (the PCR primer selects reads with this sequence), and here we observe a specific base for each cycle across all the samples.


```{r qc_figure_set1}
plot(qc_noFilter) 
```

We can also choose to plot one of the `BarcodeQc` in the `BarcodeQcSet` object. In the
output, there are three panels. The top left one shows the reads depth 
distribution, the top right figure shows the "ATCG" base ratio by each
sequencing cycle, and the last one shows the sequencing quality by sequencing
cycle.

```{r qc_figure_single1}
class(qc_noFilter[[1]])
plot(qc_noFilter[[1]]) 
```

## Filter low quality sequences

`bc_filterSeq` reads in the sequence data and applies filters, then returns a
`ShortReadQ` object which contains the filtered sequences. 

The `bc_filterSeq` function can read fastq files, and it can also handle
sequencing reads in `ShortReadQ`, `DNAStringSet` and `data.frame`.

The currently available filter parameters are: 
- min_average_quality: average base sequencing quality across read.
- min_read_length: minimum number of bases per read.
- N_threshold: maximum number of "N" bases in sequence.
 
```{r filter_low_quality_seq}
# TODO: output the filtering percentage
# TODO: Trimming
fq_filter <- bc_filterSeq(
  fq_files,
  min_average_quality = 30,
  min_read_length = 60,
  sample_name = sample_name)

fq_filter
plot(bc_seqQC(fq_filter))
```

# Parse reads to get barcode

One of the core applications of this package is parsing the sequences to get
the barcode (and UMI). Our package uses regular expressions to identify
barcodes (and UMI) from sequencing reads. This is how we tell `bc_extract` the structure of the input sequences.

3 arguments are necessary for `bc_extract`, they are:
- x: the sequence data, it can be in fastq, `ShortReadQ`, `DNAStringSet` or
  `data.frame` format.
- pattern: the sequence pattern regular expression.
- pattern_type: pattern description.

The `pattern` argument is the regular expression, it tells the function where
to find the barcode (or UMI). We capture the barcode (or UMI) by `()` in the
backbone. For the sequence captured by `()`, the `pattern_type` argument tells
which is the UMI or the barcode. In the example

```{r}
pattern <- "([ACGT]{12})CTCGAGGTCATCGAAGTATCAAG([ACGT]+)TAGCAAGCTC"
pattern_type <- c("UMI" = 1, "barcode" = 2)
```

1. The sequence starts with 12 base pairs of random sequence, which is UMI. It
   is the first barcode captured by `()` in the `pattern` argument, and corresponds to
   `UMI = 1` in the `pattern_type` argument.
2. Then, there is a known constant sequence: `CCTCGAGGTCATCGAAGTATCAAG`.
3. Following the constant region, there is flexible length random sequence. This is the
   barcode which is trapped by second `()`, and it is defined by `barcode = 2`
   in the `pattern_type` argument.
4. At the end of the sequence, there is another constant sequence `TAGCAAGCTC`.

In the regular expression, the UMI pattern is retrieved with `[ACGT]{12}`. The `[ACGT]` means to match "A", "C", "G" or "T", and the `{12}` means match 12 `[ACGT]`. In the barcode
pattern `[ACGT]+`, again `[ACGT]` means match "A", "C", "G" or "T" and the `+` says to match at least one `[ACGT]`.

The `bc_extract` function is used to extract the barcode(s) from the sequences. It returns a `BarcodeObj` object if the input is a list
or a vector of Fastq files. The `BarcodeObj` created by `bc_extract` is a `List` under the hood with two elements:
`messyBc` and `metadata`. `messyBc` is also a list, where each element is a `data.frame` corresponding to the successive samples. 
Each `data.frame` has 5 columns:

1. reads_seq: full read sequence before parsing.
2. match_seq: the sequence matched by pattern.
3. umi_seq (optional): UMI sequence, applicable when there is a UMI in `pattern`
   and `pattern_type` argument.
4. barcode_seq: barcode sequence.
5. count: how many reads a barcode has. 

If the input to `bc_extract` is just one sample, the output is a single `data.frame` with the 5 columns 1). `reads_seq`, 2). `match_seq`, 3). `umi_seq`, 4).
`barcode_seq` and 5). `count`, as described above.

The sequence in `match_seq` is a contiguous segment of the full read given in `reads_seq`. The `umi_seq` and `barcode_seq` are
contiguous segments of `match_seq`. Take note that, the `reads_seq` is the unique id for
each row. The `match_seq`, `umi_seq` or `barcode_seq` can be duplicated, due to
the potential variation in the region outside of `match_seq`. Please keep this
in mind when you use data in `$messyBc`
to perform the analysis.


## Process sequencing without UMI 

In the following example, only a barcode is extracted.

```{r extract_barcode_no_UMI}
pattern <- "CGAAGTATCAAG(.+)TAGCAAGCTCGAGAGTAGACCTACT"
bc_obj <- bc_extract(
  fq_filter,
  sample_name = sample_name,
  pattern = pattern,
  pattern_type = c(barcode = 1))

bc_obj
names(bc_obj$messyBc[[1]])
```

Here the regular expression matches a constant sequence at the beginning and the end and the barcode 
in `()` matches at least one of any character.


## Sequencing with UMI

In the following example, both UMI and barcode are extracted. The regular expression is explained above.

```{r extract_barcode_with_UMI}
pattern <- "([ACGT]{12})CTCGAGGTCATCGAAGTATCAAG([ACGT]+)TAGCAAGCTC"
bc_obj_umi <- bc_extract(
  fq_filter,
  sample_name = sample_name,
  pattern = pattern,
  maxLDist = 0,
  pattern_type = c(UMI = 1, barcode = 2))

class(bc_obj_umi)
bc_obj_umi
```

# Data managemeent of `BarcodeObj`

Besides, we provide operators to handle the data for `BarcodeObj`
object. You can easily select one or several samples by their names,
indices or metadata.


Select sample by `$` operation

```{r}
names(bc_obj_umi$messyBc[["781_mixb"]])
```

Select sample by sample names

```{r}
bc_obj_umi = bc_obj_umi[, c("781_mixa", "781_mixb")]
bc_names(bc_obj_umi)
```

Set metadata

```{r}
bc_meta(bc_obj_umi)$rep <- c("a", "b")
bc_meta(bc_obj_umi)
```

Select sample by metadata

```{r}
bc_obj_umi[, rep == "a"]
bc_subset(bc_obj_umi, sample = rep == "a")
```

# Barcode filtering

`bc_extract` will output all the barcodes found in the sequences. Some of
the identified barcodes may come from PCR or sequencing errors. The `bc_cure_*`
functions perform filtering for barcodes. The `bc_cure_*`
functions create or update the `cleanBc` element in `BarcodeObj`. The `cleanBc`
element contains 2 columns
  - barcode_seq: barcode sequence
  - counts: reads depth or UMI count

In the `bc_cure_*` function family, there is:

- `bc_cure_depth` perform filtering by sequence depth.
  - depth: sequence depth.
  - isUpdate: if true the bc_cure will perform filtering on the `cleanBc`
    element and update it, otherwise `messyBc` will be used and update
    `cleanBc`.

- `bc_cure_umi` it processes the `messyBc` element, filtering based on the
  UMI-barcode reads counts, the available arguments, 
  - depth: minimum read depth for a UMI.
  - doFish: if true, "fish" for UMIs with true barcodes with UMI depth below the threshold. The consequence of "doFish" will not increase the number of identified barcodes, but the UMI counts will increase due to including the low depth UMI barcodes.
  - isUniqueUMI: in data, a single UMI can be detected with multiple different barcodes. Do you believe the UMI
    is absolutely unique? If yes, then the most abundant UMI-barcode will be
    picked for a specific UMI, and less abundant barcodes with the same UMI are
    obsolete.
    
- `bc_cure_cluster` do clustering to merge the barcodes with insufficient
  depth (or UMI counts) to the most abundant ones, it needs the `cleanBc`
  element and will update it.
  - distance: a single or a vector of integer, specifying the editing
    distance threshold of merging two similar barcode sequences. 
  - barcode_n: max barcode number, when this number is reached the clustering will
    stop and the remaining barcodes are obsolete.
  - dist_method: the distance algorithm, currently only "hamm" (Hamming distance) available.
  - merge_method: the distance algorithm, only "greedy" available currently.
  - dist_method: A  character string, specifying the distance algorithm used
    to evaluate the barcodes similarity. It can be "hamm" for Hamming distance or
    "leven" for Levenshtein distance.
  - merge_method: A character string specifying the algorithm used to
    perform the clustering merging of two barcodes. Currently only "greedy" is
    available, in this case, the least abundant barcode is merged to the most
    abundant ones.
  - barcode_n: A single or vector of integer, specifying the max sequences
    number to get. When the most abundant barcodes number reaches this number
    the merging finished, and all the rest sub-abundent sequences are
    discarded. 
  - dist_costs: A list, the costs of the events when calculate distance
    between to barcode sequences, applicable when Levenshtein distance is 
    applied. The names of vector can be of "insert", "delete" and "replace",
    specifying the weight of insertion, deletion, replacement events
    respectively. The default cost for each evens is 1.
  
 
```{r correct_barcodde_with_UMI}
# Filter the barcode with UMI-barcode pairs > 1, and treat UMI as absolute
# unique and do "fish"
bc_obj_umi <- bc_cure_umi(bc_obj_umi, depth = 1, isUniqueUMI = T, doFish = T)
# Apply the UMI count filter, keep barcode > 3 UMI
bc_obj_umi <- bc_cure_depth(bc_obj_umi, depth = 3)
bc_meta(bc_obj_umi)
bc_obj_umi
bc_2matrix(bc_obj_umi)
```

# Miscellaneous

We provides functions to transform the barcode information in `BarcodeObj` to
more general R data types.

## Sample names

```{r}
bc_names(bc_obj_umi)
```

## `BarcodeObj` to `data.frame`

The `cleanBc` will be used, the columns in the output:
  - barcode_seq: barcode sequence
  - sample_name
  - count: reads or UMI count
 
```{r}
bc_2df(bc_obj_umi)
```

Or if you prefer `data.table`

```{r}
bc_2dt(bc_obj_umi)
```

## BarcodeObj to matrix

The `cleanBc` will be used, the output is reads count or UMI count matrix, with
barcodes in rows and samples in columns.

```{r misc}
bc_2matrix(bc_obj_umi)
```

## Combination

You can combined several operations together to accomplish more complex
operations.

In the following example, the sample barcode is selected in one sample, then
get the result in `data.frame` format.

```{r}
bc_2df(bc_obj_umi[bc_barcodes(bc_obj_umi)[1], "781_mixa"])
```

# Session Info

```{r}
sessionInfo()
```
